{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>FlatBuffers is an efficient cross platform serialization library for C++, C#, C, Go, Java, Kotlin, JavaScript, Lobster, Lua, TypeScript, PHP, Python, Rust and Swift. It was originally created at Google for game development and other performance-critical applications.</p> <p>It is available as Open Source on GitHub under the Apache license v2.0.</p>"},{"location":"#why-use-flatbuffers","title":"Why Use FlatBuffers?","text":"<ul> <li> <p> Access to serialized data without   parsing/unpacking</p> <p>Access the data directly without unpacking or parsing.</p> </li> <li> <p> Memory Efficiency and Speed</p> <p>The only memory needed to access your data is that of the buffer. No heap is   required.</p> </li> <li> <p> Backwards and Forwards   Compatibility</p> <p>The only memory needed to access your data is that of the buffer. No heap is   required.</p> </li> <li> <p> Small Footprint</p> <p>Minimal dependencies and small code footprint.</p> </li> </ul>"},{"location":"#why-not-use","title":"Why not use...","text":"Protocol BuffersJSON <p>Protocol Buffers is indeed relatively similar to FlatBuffers, with the primary difference being that FlatBuffers does not need a parsing/unpacking step to a secondary representation before you can access data, often coupled with per-object memory allocation. The code is an order of magnitude bigger, too.</p> <p>JSON is very readable (which is why we use it as our optional text format) and very convenient when used together with dynamically typed languages (such as JavaScript). When serializing data from statically typed languages, however, JSON not only has the obvious drawback of runtime inefficiency, but also forces you to write more code to access data (counterintuitively) due to its dynamic-typing serialization system. In this context, it is only a better choice for systems that have very little to no information ahead of time about what data needs to be stored.</p>"},{"location":"annotation/","title":"Annotating FlatBuffers","text":"<p>This provides a way to annotate flatbuffer binary data, byte-by-byte, with a schema. It is useful for development purposes and understanding the details of the internal format.</p>"},{"location":"annotation/#annotating","title":"Annotating","text":"<p>Given a <code>schema</code>, as either a plain-text (<code>.fbs</code>) or a binary schema (<code>.bfbs</code>), and <code>binary</code> file(s) that were created by the <code>schema</code>. You can annotate them using:</p> <pre><code>flatc --annotate SCHEMA -- BINARY_FILES...\n</code></pre> <p>This will produce a set of annotated files (<code>.afb</code> Annotated FlatBuffer) corresponding to the input binary files.</p>"},{"location":"annotation/#example","title":"Example","text":"<p>Taken from the tests/annotated_binary.</p> <pre><code>cd tests/annotated_binary\n../../flatc --annotate annotated_binary.fbs -- annotated_binary.bin\n</code></pre> <p>Which will produce a <code>annotated_binary.afb</code> file in the current directory.</p> <p>Tip</p> <p>The <code>annotated_binary.bin</code> is the flatbufer binary of the data contained within <code>annotated_binary.json</code>, which was made by the following command:</p> <pre><code>..\\..\\flatc -b annotated_binary.fbs annotated_binary.json\n</code></pre>"},{"location":"annotation/#afb-text-format","title":".afb Text Format","text":"<p>Currently there is a built-in text-based format for outputting the annotations. A full example is shown here: <code>annotated_binary.afb</code></p> <p>The data is organized as a table with fixed columns grouped into Binary sections and regions, starting from the beginning of the binary (offset <code>0</code>).</p>"},{"location":"annotation/#columns","title":"Columns","text":"<p>The columns are as follows:</p> <ol> <li> <p>The offset from the start of the binary, expressed in hexadecimal format    (e.g. <code>+0x003c</code>).</p> <p>The prefix <code>+</code> is added to make searching for the offset (compared to some random value) a bit easier.</p> </li> <li> <p>The raw binary data, expressed in hexadecimal format. </p> <p>This is in the little endian format the buffer uses internally and what you would see with a normal binary text viewer.</p> </li> <li> <p>The type of the data.</p> <p>This may be the type specified in the schema or some internally defined types:</p> Internal Type Purpose <code>VOffset16</code> Virtual table offset, relative to the table offset <code>UOffset32</code> Unsigned offset, relative to the current offset <code>SOffset32</code> Signed offset, relative to the current offset </li> <li> <p>The value of the data.</p> <p>This is shown in big endian format that is generally written for humans to consume (e.g. <code>0x0013</code>). As well as the \"casted\" value (e.g. <code>0x0013</code>is <code>19</code> in decimal) in parentheses.</p> </li> <li> <p>Notes about the particular data.</p> <p>This describes what the data is about, either some internal usage, or tied to the schema.</p> </li> </ol>"},{"location":"annotation/#binary-sections","title":"Binary Sections","text":"<p>The file is broken up into Binary Sections, which are comprised of contiguous binary regions that are logically grouped together. For example, a binary section may be a single instance of a flatbuffer <code>Table</code> or its <code>vtable</code>. The sections may be labelled with the name of the associated type, as defined in the input schema.</p> <p>An example of a <code>vtable</code> Binary Section that is associated with the user-defined <code>AnnotateBinary.Bar</code> table.</p> <pre><code>vtable (AnnotatedBinary.Bar):\n  +0x00A0 | 08 00      | uint16_t   | 0x0008 (8)   | size of this vtable\n  +0x00A2 | 13 00      | uint16_t   | 0x0013 (19)  | size of referring table\n  +0x00A4 | 08 00      | VOffset16  | 0x0008 (8)   | offset to field `a` (id: 0)\n  +0x00A6 | 04 00      | VOffset16  | 0x0004 (4)   | offset to field `b` (id: 1)\n</code></pre> <p>These are purely annotative, there is no embedded information about these regions in the flatbuffer itself.</p>"},{"location":"annotation/#binary-regions","title":"Binary Regions","text":"<p>Binary regions are contiguous bytes regions that are grouped together to form  some sort of value, e.g. a <code>scalar</code> or an array of scalars. A binary region may be split up over multiple text lines, if the size of the region is large.</p>"},{"location":"annotation/#annotation-example","title":"Annotation Example","text":"<p>Looking at an example binary region:</p> <pre><code>vtable (AnnotatedBinary.Bar):\n  +0x00A0 | 08 00      | uint16_t   | 0x0008 (8)   | size of this vtable\n</code></pre> <p>The first column (<code>+0x00A0</code>) is the offset to this region from the beginning of the buffer. </p> <p>The second column are the raw bytes (hexadecimal) that make up this region. These are expressed in the little-endian format that flatbuffers uses for the wire format.</p> <p>The third column is the type to interpret the bytes as. For the above example, the type is <code>uint16_t</code> which is a 16-bit unsigned integer type.</p> <p>The fourth column shows the raw bytes as a compacted, big-endian value. The raw bytes are duplicated in this fashion since it is more intuitive to read the data in the big-endian format (e.g., <code>0x0008</code>). This value is followed by the decimal representation of the value (e.g., <code>(8)</code>). For strings, the raw string value is shown instead. </p> <p>The fifth column is a textual comment on what the value is. As much metadata as known is provided.</p>"},{"location":"annotation/#offsets","title":"Offsets","text":"<p>If the type in the 3rd column is of an absolute offset (<code>SOffet32</code> or <code>Offset32</code>), the fourth column also shows an <code>Loc: +0x025A</code> value which shows where in the binary this region is pointing to. These values are absolute from the beginning of the file, their calculation from the raw value in the 4th column depends on the context.</p>"},{"location":"building/","title":"Building","text":""},{"location":"building/#building-with-cmake","title":"Building with CMake","text":"<p>The distribution main build system is configured by <code>cmake</code> which allows you to build the project for any platform.</p>"},{"location":"building/#configuration","title":"Configuration","text":"<p>Use <code>cmake</code> to configure a project based on your environment and platform.</p> UnixWindowsMacOS <pre><code>cmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release\n</code></pre> <p>Note</p> <p>To use <code>clang</code> instead of <code>gcc</code> you may need to set prepend some environment variables e.g. <code>CC=/usr/bin/clang CXX=/usr/bin/clang++ cmake -G \"Unix MakeFiles\"</code></p> <pre><code>cmake -G \"Visual Studio 17 2022\" -DCMAKE_BUILD_TYPE=Release\n</code></pre> <pre><code>cmake -G \"Xcode\" -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"building/#building_1","title":"Building","text":"<p>Once the project files are generated, build as normal for your platform.</p> UnixWindowsMacOS <pre><code>make -j\n</code></pre> <pre><code>msbuild.exe FlatBuffers.sln\n</code></pre> <pre><code>xcodebuild -toolchain clang -configuration Release\n</code></pre>"},{"location":"building/#building-with-bazel","title":"Building with Bazel","text":""},{"location":"building/#building-with-vcpkg","title":"Building with VCPKG","text":""},{"location":"contributing/","title":"Contributing","text":"<p>We encourage community contributions to FlatBuffers through pull requests at the main http://github.com/google/flatbuffers repository.</p> <p>Note</p> <p>The FlatBuffers project is not staffed by any full time Google employee, and is managed by a small team of 20%ers. So response time and expertise vary.</p>"},{"location":"contributing/#before-you-contribute","title":"Before you contribute","text":"<p>Before we can use your contributions, you must sign one of the following license agreements. The agreements are self-served at the following links.</p> <p>Our code review process will automatically check if you have signed the CLA, so don't fret. Though it may be prudent to check before spending a lot of time on  contribution.</p>"},{"location":"contributing/#individual-contributions","title":"Individual Contributions","text":"<p>For individuals, the Google Individual Contributor License Agreement (CLA) which is self served at the link. The CLA is required since you own the copyright to your changes, even after your contribution becomes part of our codebase, so we need your permission to use and distribute your code. </p>"},{"location":"contributing/#corporate-contributions","title":"Corporate Contributions","text":"<p>Contributions made by corporations are covered by the Google Software Grant and Corporate Contributor License Agreement.</p>"},{"location":"contributing/#code-reviews","title":"Code Reviews","text":"<p>All submissions require a code review via Github Pull Requests.</p> <ol> <li>Please adhere to the Google Style Guide for the language(s) you are submitting in.</li> <li>Keep PRs small and focused. Its good practice and makes it more likely your PR will be approved.</li> <li>Please add tests if possible.</li> <li>Include descriptive commit messages and context to the change/issues fixed.</li> </ol>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>FlatBuffers uses MkDocs to generate the static documentation pages served at https://flatbuffers.dev. Specifically, we use the Material for MkDocs framework.</p> <p>The documentation source is contained in the main repo under the docs/ directory. This automatically get built and published when the commit is made.</p>"},{"location":"contributing/#local-development","title":"Local Development","text":"<p>We encourage contributors to keep the documentation up-to-date as well, and it is easy to with <code>MkDocs</code> local building and serving tools.</p> <p>First install <code>mkdocs-material</code> (see Installation for other ways)</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>Then, in the <code>root</code> directory of flatbuffers, run </p> <pre><code>mkdocs serve -f docs/mkdocs.yml\n</code></pre> <p>This will continually watch the repo for changes to the documentation and serve the rendered pages locally.</p> <p>Submit your documentation changes with your code changes and they will automatically get published when your code is submitted.</p>"},{"location":"evolution/","title":"Evolution","text":"<p>FlatBuffers enables the schema to evolve over time while still maintaining forwards and backwards compatibility with old flatbuffers.</p> <p>Some rules must be followed to ensure the evolution of a schema is valid.</p>"},{"location":"evolution/#rules","title":"Rules","text":"<p>Adding new tables, vectors, structs to the schema is always allowed. Its only when you add a new field to a <code>table</code> that certain rules must be followed.</p>"},{"location":"evolution/#addition","title":"Addition","text":"<p>New fields MUST be added to the end of the table definition.</p> <p>This allows older data to still be read correctly (giving you the default value of the added field if accessed).</p> <p>Older code will simply ignore the new field in the flatbuffer.</p> <p>Use <code>id</code> attributes</p> <p>You can ignore this rule if you use the <code>id</code> attribute on all the fields of a table. This</p>"},{"location":"evolution/#removal","title":"Removal","text":"<p>You MUST not remove a field from the schema, even if you don't use it anymore. You simply stop writing them to the buffer.</p> <p>Its encouraged to mark the field deprecated by adding the <code>deprecated</code> attribute. This will skip the generation of accessors and setters in the code, to enforce the field not to be used any more.</p>"},{"location":"evolution/#name-changes","title":"Name Changes","text":"<p>Its generally OK to change the name of tables and fields, as these are not serialized to the buffer. It may break code that would have to be refactored with the updated name.</p>"},{"location":"evolution/#examples","title":"Examples","text":"<p>The following examples uses a base schema and attempts to evolve it a few times. The versions are tracked by <code>V1</code>, <code>V2</code>, etc.. and <code>CodeV1</code> means code compiled against the <code>V1</code> schema.</p>"},{"location":"evolution/#table-evolution","title":"Table Evolution","text":"<p>Lets start with a simple table <code>T</code> with two fields.</p> Schema V1<pre><code>table T {\n  a:int;\n  b:int;\n}\n</code></pre> Well EvolvedImproper AdditionImproper DeletionProper ReorderingChanging TypesChanging DefaultsRenaming Fields <p>First lets extend the table with a new field.</p> Schema V2<pre><code>table T {\n  a:int;\n  b:int;\n  c:int;\n}\n</code></pre> <p>This is OK. <code>CodeV1</code> reading <code>V2</code> data will simply ignore the presence of the new field <code>c</code>. <code>CodeV2</code> reading <code>V1</code> data will get a default value (0) when reading <code>c</code>.</p> Schema V3<pre><code>table T {\n  a:int (deprecated);\n  b:int;\n  c:int;\n}\n</code></pre> <p>This is OK, removing field <code>a</code> via deprecation. <code>CodeV1</code>, <code>CodeV2</code> and <code>CodeV3</code> reading <code>V3</code> data will now always get the default value of <code>a</code>, since it is not present. <code>CodeV3</code> cannot write <code>a</code> anymore. <code>CodeV3</code> reading old data (<code>V1</code> or <code>V2</code>) will not be able to access the field anymore, since no generated accessors are omitted.</p> <p>Add a new field, but this time at the beginning.</p> Schema V2<pre><code>table T {\n  c:int;\n  a:int;\n  b:int;\n}\n</code></pre> <p>This is NOT OK, as it makes <code>V2</code> incompatible. <code>CodeV1</code> reading <code>V2</code> data will access <code>a</code> but will read <code>c</code> data.</p> <p><code>CodeV2</code> reading <code>V1</code> data will access <code>c</code> but will read <code>a</code> data.</p> <p>Remove a field from the schema.</p> Schema V2<pre><code>table T {\n  b:int;\n}\n</code></pre> <p>This is NOT OK. <code>CodeV1</code> reading <code>V2</code> data will access <code>a</code> but read <code>b</code> data.</p> <p><code>CodeV2</code> reading <code>V1</code> data will access <code>b</code> but will read <code>a</code> data.</p> <p>Lets add a new field to the beginning, but use <code>id</code> attributes.</p> Schema V2<pre><code>table T {\n  c:int (id: 2);\n  a:int (id: 0);\n  b:int (id: 1);\n}\n</code></pre> <p>This is OK. This adds the a new field in the beginning, but because all the <code>id</code> attributes were added, it is OK.</p> <p>Let change the types of the fields.</p> Schema V2<pre><code>table T {\n  a:uint;\n  b:uint;\n}\n</code></pre> <p>This is MAYBE OK, and only in the case where the type change is the same width. This is tricky if the <code>V1</code> data contained any negative numbers. So this should be done with care.</p> <p>Lets change the default values of the existing fields.</p> Schema V2<pre><code>table T {\n  a:int = 1;\n  b:int = 2;\n}\n</code></pre> <p>This is NOT OK. Any <code>V1</code> data that did not have a value written to the buffer relied on generated code to provide the default value.</p> <p>There MAY be cases where this is OK, if you control all the producers and consumers, and you can update them in tandem.</p> <p>Lets change the name of the fields</p> Schema V2<pre><code>table T {\n  aa:int;\n  bb:int;\n}\n</code></pre> <p>This is generally OK. You've renamed fields will break all code and JSON files that use this schema, but you can refactor those without affecting the binary data, since the binary only address fields by id and offset, not by names.</p>"},{"location":"evolution/#union-evolution","title":"Union Evolution","text":"<p>Lets start with a simple union <code>U</code> with two members.</p> Schema V1<pre><code>union U {\n  A,\n  B\n}\n</code></pre> Well EvolvedImproper EvolvedEvolved With Discriminant <p>Lets add a another variant to the end.</p> Schema V2<pre><code>union U {\n  A,\n  B,\n  another_a: A\n}\n</code></pre> <p>This is OK. <code>CodeV1</code> will not recognize the <code>another_a</code>.</p> <p>Lets add a another variant to the middle.</p> Schema V2<pre><code>union U {\n  A,\n  another_a: A,\n  B\n}\n</code></pre> <p>This is NOT OK. <code>CodeV1</code> reading <code>V2</code> data will interpret <code>B</code> as <code>another_a</code>. <code>CodeV2</code> reading <code>V1</code> data will interpret <code>another_a</code> as <code>B</code>.</p> <p>Lets add a another variant to the middle, this time adding a union \"discriminant\".</p> Schema V2<pre><code>union U {\n  A = 1,\n  another_a: A = 3,\n  B = 2\n}\n</code></pre> <p>This is OK. Its like you added it to the end, but using the discriminant value to physically place it elsewhere in the union.</p>"},{"location":"evolution/#version-control","title":"Version Control","text":"<p>FlatBuffers relies on new field declarations being added at the end, and earlier declarations to not be removed, but be marked deprecated when needed. We think this is an improvement over the manual number assignment that happens in Protocol Buffers (and which is still an option using the <code>id</code> attribute mentioned above).</p> <p>One place where this is possibly problematic however is source control. If user <code>A</code> adds a field, generates new binary data with this new schema, then tries to commit both to source control after user <code>B</code> already committed a new field also, and just auto-merges the schema, the binary files are now invalid compared to the new schema.</p> <p>The solution of course is that you should not be generating binary data before your schema changes have been committed, ensuring consistency with the rest of the world. If this is not practical for you, use explicit field <code>id</code>s, which should always generate a merge conflict if two people try to allocate the same id.</p>"},{"location":"flatc/","title":"FlatBuffers Compiler (<code>flatc</code>)","text":"<p>The main compiler for FlatBuffers is called <code>flatc</code> and is used to convert schema definitions into generated code files for a variety of languages. </p> <p>After building <code>flatc</code>, it is used as follows:</p> <pre><code>flatc [ GENERATOR_OPTIONS ] [ -o PATH ] [- I PATH ] \n  FILES... \n  [ -- BINARY_FILES... ]\n</code></pre> <ul> <li> <p>The <code>GENERATOR_OPTIONS</code> specify the language(s) to compile code for as well as various features to enable/disable.</p> </li> <li> <p>The <code>-o PATH</code> specifies the path where the generated files are placed. It defaults to the current path if not specified.</p> </li> <li> <p>The <code>-I PATH</code> specifies the paths where included schema files are located. It   defaults to the current path if not specified.</p> </li> </ul>"},{"location":"flatc/#input-files","title":"Input Files","text":"<p><code>FILES...</code> specifies one or more schema or data files to process. They are processed in the order provided.</p>"},{"location":"flatc/#schema-files","title":"Schema Files","text":"<p>For schema files, language specifiers indicate what languages to generate code for.</p> <ul> <li><code>--cpp</code>: C++</li> <li><code>--java</code>: Java</li> <li><code>--kotlin</code>: Kotlin</li> <li><code>--csharp</code>: C#</li> <li><code>--go</code>: Golang</li> <li><code>--python</code>: Python</li> <li><code>--js</code>: JavaScript</li> <li><code>--ts</code>: TypeScript</li> <li><code>--php</code>: PHP</li> <li><code>--dart</code>: Dart</li> <li><code>--lua</code>: Lua</li> <li><code>--lobster</code>: Lobster</li> <li><code>--rust</code>: Rust</li> <li><code>--swift</code>: Swift</li> <li><code>--nim</code>: Nim</li> </ul> <p>Additionally, adding:</p> <ul> <li><code>--grpc</code> Will generate RPC stub code for gRPC (not available in all     languages)</li> </ul>"},{"location":"flatc/#data-files","title":"Data Files","text":"<p>If <code>FILES...</code> contain data files, they can be exported to either a binary or JSON representation.</p> <ul> <li><code>--binary</code>, <code>-b</code>: Generate a binary file containing a serialized flatbuffer.</li> <li><code>--json</code>, <code>-j</code>: Generate JSON file from a serialized flatbuffer.</li> </ul> <p>Both options require the corresponding schema file to be included first in the list of <code>FILES...</code>.</p> To BinaryTo JSON <p>To serialize the JSON data in <code>mydata.json</code> using the schema <code>myschema.fbs</code>:</p> <pre><code>flatc --binary myschema.fbs mydata.json\n</code></pre> <p>This will generate a <code>mydata_wire.bin</code> file containing the serialized  flatbuffer data.</p> <p>To convert the serialized binary flatbuffer <code>mydata.bin</code> using the schema  <code>myschema.fbs</code> to JSON:</p> <pre><code>flatc --json myschema.fbs mydata.bin\n</code></pre> <p>This will generate a <code>mydata.json</code> file.</p>"},{"location":"grammar/","title":"Grammar","text":""},{"location":"grammar/#ebnf","title":"EBNF","text":"<pre><code>schema = include* ( namespace_decl | type_decl | enum_decl | root_decl |\n           file_extension_decl | file_identifier_decl |\n           attribute_decl | rpc_decl | object )*\n\ninclude = `include` string_constant `;`\n\nnamespace_decl = `namespace` ident ( `.` ident )* `;`\n\nattribute_decl = `attribute` ident | `\"` ident `\"` `;`\n\ntype_decl = ( `table` | `struct` ) ident metadata `{` field_decl+ `}`\n\nenum_decl = ( `enum` ident `:` type | `union` ident )  metadata `{`\ncommasep( enumval_decl ) `}`\n\nroot_decl = `root_type` ident `;`\n\nfield_decl = ident `:` type [ `=` scalar ] metadata `;`\n\nrpc_decl = `rpc_service` ident `{` rpc_method+ `}`\n\nrpc_method = ident `(` ident `)` `:` ident metadata `;`\n\ntype = `bool` | `byte` | `ubyte` | `short` | `ushort` | `int` | `uint` |\n       `float` | `long` | `ulong` | `double` | `int8` | `uint8` | `int16` |\n       `uint16` | `int32` | `uint32`| `int64` | `uint64` | `float32` |\n       `float64` | `string` | `[` type `]` | ident\n\nenumval_decl = ident [ `=` integer_constant ] metadata\n\nmetadata = [ `(` commasep( ident [ `:` single_value ] ) `)` ]\n\nscalar = boolean_constant | integer_constant | float_constant\n\nobject = `{` commasep( ident `:` value ) `}`\n\nsingle_value = scalar | string_constant\n\nvalue = single_value | object | `[` commasep( value ) `]`\n\ncommasep(x) = [ x ( `,` x )\\* ]\n\nfile_extension_decl = `file_extension` string_constant `;`\n\nfile_identifier_decl = `file_identifier` string_constant `;`\n\nstring_constant = `\\\".*?\\\"`\n\nident = `[a-zA-Z_][a-zA-Z0-9_]*`\n\n`[:digit:]` = `[0-9]`\n\n`[:xdigit:]` = `[0-9a-fA-F]`\n\ndec_integer_constant = `[-+]?[:digit:]+`\n\nhex_integer_constant = `[-+]?0[xX][:xdigit:]+`\n\ninteger_constant = dec_integer_constant | hex_integer_constant\n\ndec_float_constant = `[-+]?(([.][:digit:]+)|([:digit:]+[.][:digit:]*)|([:digit:]+))([eE][-+]?[:digit:]+)?`\n\nhex_float_constant = `[-+]?0[xX](([.][:xdigit:]+)|([:xdigit:]+[.][:xdigit:]*)|([:xdigit:]+))([pP][-+]?[:digit:]+)`\n\nspecial_float_constant = `[-+]?(nan|inf|infinity)`\n\nfloat_constant = dec_float_constant | hex_float_constant | special_float_constant\n\nboolean_constant = `true` | `false`\n</code></pre>"},{"location":"quick_start/","title":"Quick Start","text":"<p>This will quickly go over the parts of using FlatBuffers to serialize some data. See the Tutorial for a more in depth guide.</p> <ol> <li> <p>Build the compiler for FlatBuffers (<code>flatc</code>)</p> <pre><code>cmake -G \"Unix Makefiles\"\nmake -j\n</code></pre> </li> <li> <p>Define your FlatBuffer schema (<code>.fbs</code>)</p> monster.fbs<pre><code>table Monster {\n  name:string;\n  health:int;\n}\n\nroot_type Monster;\n</code></pre> <p>See monster.fbs for an complete example.</p> </li> <li> <p>Generate code for your language(s)</p> <p>Use the <code>flatc</code> compiler to take your schema and generate language-specific code:</p> <pre><code>./flatc --cpp --rust mosnter.fbs\n</code></pre> <p>Which generates <code>monster_generated.h</code> and <code>monster_generated.rs</code> files.</p> </li> <li> <p>Serialize data</p> <p>Use the generated code files, as well as the <code>FlatBufferBuilder</code> to construct your serialized buffer.</p> my_monster_factory.cc<pre><code>#include \"flatbuffers.h\"\n#include \"monster_generated.h\"\n\nint main() { \n  // Used to build the flatbuffer\n  FlatBufferBuilder builder;\n\n  // Auto-generated function emitted from `flatc` and the input \n  // `monster.fbs` schema.\n  auto monster = CreateMonsterDirect(builder, \"Abominable Snowman\", 100);\n\n  // Finalize the buffer.\n  builder.Finish(monster);\n}\n</code></pre> <p>See complete C++ Example.</p> </li> <li> <p>Transmit/Store the serialized FlatBuffer</p> <p>Use your serialized buffer however you want. Send it to someone, save if for later, etc...</p> my_monster_factory.cc<pre><code>// Get a pointer to the flatbuffer.\nconst uint8_t* flatbuffer = builder.GetBufferPointer();\n</code></pre> </li> <li> <p>Read the data</p> <p>Use the generated accessors to read the data from the serialized buffer.</p> <p>It doesn't need to be the same language, or even schema version (see  Evolving), FlatBuffers ensures the data is readable across languages and schema versions. </p> my_monster_factory.cc<pre><code>// Get a view of the root monster from the flatbuffer.\nconst Monster snowman = GetMonster(flatbuffer);\n\n// Access the monster's fields directly.\nASSERT_EQ(snowman.name(), \"Abominable Snowman\");\nASSERT_EQ(snowman.health(), 100);\n</code></pre> <p>See <code>Rust</code> examples for reading the data written by <code>C++</code>.</p> </li> </ol>"},{"location":"schema/","title":"Schema","text":"<p>The syntax of the schema language (aka IDL, Interface Definition Language) should look quite familiar to users of any of the C family of languages, and also to users of other IDLs. Let's look at an example first:</p> monster.fbs<pre><code>// example IDL file\n\nnamespace MyGame;\n\nattribute \"priority\";\n\nenum Color : byte { Red = 1, Green, Blue }\n\nunion Any { Monster, Weapon, Pickup }\n\nstruct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n\ntable Monster {\n  pos:Vec3;\n  mana:short = 150;\n  hp:short = 100;\n  name:string;\n  friendly:bool = false (deprecated, priority: 1);\n  inventory:[ubyte];\n  color:Color = Blue;\n  test:Any;\n}\n\ntable Weapon {}\ntable Pickup {}\n\nroot_type Monster;\n</code></pre>"},{"location":"schema/#tables","title":"Tables","text":"<p>Tables are the main way of defining objects in FlatBuffers.</p> monster.fbs - Example Table<pre><code>table Monster {\n  pos:Vec3;\n  mana:short = 150;\n  hp:short = 100;\n  name:string;\n  friendly:bool = false (deprecated, priority: 1);\n  inventory:[ubyte];\n  color:Color = Blue;\n  test:Any;\n}\n</code></pre> <p>They consist of a name (here <code>Monster</code>) and a list of fields. This field list can be appended to (and deprecated from) while still maintaining compatibility.</p>"},{"location":"schema/#fields","title":"Fields","text":"<p>Table fields have a name identifier, a type, optional default value, optional attributes and ends with a <code>;</code>. See the grammar for full details.</p> <pre><code>field_decl = ident `:` type [ `=` scalar ] metadata `;`\n</code></pre> <p>Fields do not have to appear in the wire representation, and you can choose to omit fields when constructing an object. You have the flexibility to add fields without fear of bloating your data. This design is also FlatBuffer's mechanism for forward and backwards compatibility.</p> <p>There are three, mutually exclusive, reactions to the non-presence of a table's field in the binary data.</p>"},{"location":"schema/#1-default","title":"1. Default","text":"<p>Default value fields with return the default value as defined in the schema. If the default value is not specified in the schema, it will be <code>0</code> for scalar types, or <code>null</code> for other types.</p> <pre><code>mana:short = 150;\nhp:short;\ninventory:[ubyte];\n</code></pre> <p>Here <code>mana</code> would default to the value <code>150</code>, <code>hp</code> to value <code>0</code>, and <code>inventory</code> to <code>null</code>, if those fields are not set.</p> <p>Only scalar values can have explicit defaults, non-scalar fields (strings, vectors, tables) are <code>null</code> when not present.</p> <p>This is the normal mode that fields will take.</p> Don't change Default values <p>You generally do not want to change default values after they're initially defined. Fields that have the default value are not actually stored in the serialized data (see also Gotchas below). Values explicitly written by code generated by the old schema old version, if they happen to be the default, will be read as a different value by code generated with the new schema. This is slightly less bad when converting an optional scalar into a default valued scalar since non-presence would not be overloaded with a previous default value. There are situations, however, where this may be desirable, especially if you can ensure a simultaneous rebuild of all code.</p>"},{"location":"schema/#2-optional","title":"2. Optional","text":"<p>Optional value fields will return some form of <code>null</code> in the language generated.</p> C++ <pre><code>std::optional&lt;T&gt; field;\n</code></pre> <p>For optional scalars, just set the field default value to <code>null</code>. If the producer of the buffer does not explicitly set that field, it will be marked <code>null</code>.</p> <pre><code>  hp:short = null;\n</code></pre> <p>Note</p> <p>Not every languages support scalar defaults yet</p>"},{"location":"schema/#3-required","title":"3. Required","text":"<p>Required valued fields will cause an error if they are not set. The FlatBuffers verifier would consider the whole buffer invalid.</p> <p>This is enabled by the <code>required</code> attribute on the field.</p> <pre><code>  hp:short (required)\n</code></pre> <p>You cannot have <code>required</code> set with an explicit default value, it will result in a compiler error.</p>"},{"location":"schema/#structs","title":"Structs","text":"<p>Similar to a table, <code>structs</code> consist of fields are required (so no defaults either), and fields may not be added or be deprecated.</p> monster.fbs - Example Struct<pre><code>struct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n</code></pre> <p>Structs may only contain scalars or other structs. Use this for simple objects where you are very sure no changes will ever be made (as quite clear in the example <code>Vec3</code>). Structs use less memory than tables and are even faster to access (they are always stored in-line in their parent object, and use no virtual table).</p>"},{"location":"schema/#arrays","title":"Arrays","text":"<p>Arrays are a convenience short-hand for a fixed-length collection of elements. Arrays allow the following syntax, while maintaining binary equivalency.</p> <ul> <li>Normal Syntax</li> </ul> <p>===</p> <pre><code>struct Vec3 {\n  x:float;\n  y:float;\n  z:float;\n}\n</code></pre> <ul> <li>Array Syntax</li> </ul> <p>===</p> <pre><code>struct Vec3 {\n  v:[float:3];\n}\n</code></pre> <p>Arrays are currently only supported in a <code>struct</code>.</p>"},{"location":"schema/#types","title":"Types","text":"<p>The following are the built-in types that can be used in FlatBuffers.</p>"},{"location":"schema/#scalars","title":"Scalars","text":"<p>The standard assortment of fixed sized scalars are available. There are no variable sized integers (e.g., <code>varints</code>).</p> Size Signed Unsigned Floating Point 8-bit <code>byte</code>, <code>bool</code> <code>ubyte</code> 16-bit <code>short</code> (<code>int16</code>) <code>ushort</code> (<code>uint16</code>) 32-bit <code>int</code> (<code>int32</code>) <code>uint</code> (<code>uint32</code>) <code>float</code> (<code>float32</code>) 64-bit <code>long</code> (<code>int64</code>) <code>ulong</code> (<code>uint64</code>) <code>double</code> (<code>float64</code>) <p>Alias Types</p> <p>The type names in parentheses are alias names such that for example <code>uint8</code> can be used in place of <code>ubyte</code>, and <code>int32</code> can be used in place of <code>int</code> without affecting code generation.</p>"},{"location":"schema/#non-scalars","title":"Non-scalars","text":""},{"location":"schema/#vectors","title":"Vectors","text":"<p>Vector of any other type (denoted with <code>[type]</code>).</p> <pre><code>inventory:[ubyte];\n</code></pre> <p>Nesting vectors</p> <p>Nesting vectors is not supported, instead you can wrap the inner vector with a table.</p> <pre><code>table nest{\n   a:[ubyte]\n}\n\ntable monster {\n a:[nest]\n}\n</code></pre>"},{"location":"schema/#strings","title":"Strings","text":"<p>Strings (indicated by <code>string</code>) are zero-terminated strings, prefixed by their length. Strings may only hold UTF-8 or 7-bit ASCII. For other text encodings or general binary data use vectors (<code>[byte]</code> or <code>[ubyte]</code>) instead.</p> <pre><code>name:string;\n</code></pre>"},{"location":"schema/#enums","title":"Enums","text":"<p>Define a sequence of named constants, each with a given value, or increasing by one from the previous one. The default first value is <code>0</code>. As you can see in the enum declaration, you specify the underlying integral type of the enum with <code>:</code> (in this case <code>byte</code>), which then determines the type of any fields declared with this enum type.</p> <p>Only integer types are allowed, i.e. <code>byte</code>, <code>ubyte</code>, <code>short</code> <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>long</code> and <code>ulong</code>.</p> <p>Typically, enum values should only ever be added, never removed (there is no deprecation for enums). This requires code to handle forwards compatibility itself, by handling unknown enum values.</p>"},{"location":"schema/#unions","title":"Unions","text":"<p>Unions share a lot of properties with enums, but instead of new names for constants, you use names of tables. You can then declare a union field, which can hold a reference to any of those types, and additionally a field with the suffix <code>_type</code> is generated that holds the corresponding enum value, allowing you to know which type to cast to at runtime.</p> <p>It's possible to give an alias name to a type union. This way a type can even be used to mean different things depending on the name used:</p> <pre><code>table PointPosition { x:uint; y:uint; }\ntable MarkerPosition {}\nunion Position {\n  Start:MarkerPosition,\n  Point:PointPosition,\n  Finish:MarkerPosition\n}\n</code></pre> <p>Unions contain a special <code>NONE</code> marker to denote that no value is stored so that name cannot be used as an alias.</p> <p>Unions are a good way to be able to send multiple message types as a FlatBuffer. Note that because a union field is really two fields, it must always be part of a table, it cannot be the root of a FlatBuffer by itself.</p> <p>If you have a need to distinguish between different FlatBuffers in a more open-ended way, for example for use as files, see the file identification feature below.</p> <p>There is an experimental support only in C++ for a vector of unions (and types). In the example IDL file above, use [Any] to add a vector of Any to Monster table. There is also experimental support for other types besides tables in unions, in particular structs and strings. There's no direct support for scalars in unions, but they can be wrapped in a struct at no space cost.</p>"},{"location":"schema/#namespaces","title":"Namespaces","text":"<p>These will generate the corresponding namespace in C++ for all helper code, and packages in Java. You can use <code>.</code> to specify nested namespaces / packages.</p>"},{"location":"schema/#includes","title":"Includes","text":"<p>You can include other schemas files in your current one, e.g.:</p> <pre><code>include \"mydefinitions.fbs\";\n</code></pre> <p>This makes it easier to refer to types defined elsewhere. <code>include</code> automatically ensures each file is parsed just once, even when referred to more than once.</p> <p>When using the <code>flatc</code> compiler to generate code for schema definitions, only definitions in the current file will be generated, not those from the included files (those you still generate separately).</p>"},{"location":"schema/#root-type","title":"Root type","text":"<p>This declares what you consider to be the root table of the serialized data. This is particularly important for parsing JSON data, which doesn't include object type information.</p>"},{"location":"schema/#file-identification-and-extension","title":"File identification and extension","text":"<p>Typically, a FlatBuffer binary buffer is not self-describing, i.e. it needs you to know its schema to parse it correctly. But if you want to use a FlatBuffer as a file format, it would be convenient to be able to have a \"magic number\" in there, like most file formats have, to be able to do a sanity check to see if you're reading the kind of file you're expecting.</p> <p>Now, you can always prefix a FlatBuffer with your own file header, but FlatBuffers has a built-in way to add an identifier to a FlatBuffer that takes up minimal space, and keeps the buffer compatible with buffers that don't have such an identifier.</p> <p>You can specify in a schema, similar to <code>root_type</code>, that you intend for this type of FlatBuffer to be used as a file format:</p> <pre><code>file_identifier \"MYFI\";\n</code></pre> <p>Identifiers must always be exactly 4 characters long. These 4 characters will end up as bytes at offsets 4-7 (inclusive) in the buffer.</p> <p>For any schema that has such an identifier, <code>flatc</code> will automatically add the identifier to any binaries it generates (with <code>-b</code>), and generated calls like <code>FinishMonsterBuffer</code> also add the identifier. If you have specified an identifier and wish to generate a buffer without one, you can always still do so by calling <code>FlatBufferBuilder::Finish</code> explicitly.</p> <p>After loading a buffer, you can use a call like <code>MonsterBufferHasIdentifier</code> to check if the identifier is present.</p> <p>Note that this is best for open-ended uses such as files. If you simply wanted to send one of a set of possible messages over a network for example, you'd be better off with a union.</p> <p>Additionally, by default <code>flatc</code> will output binary files as <code>.bin</code>. This declaration in the schema will change that to whatever you want:</p> <pre><code>file_extension \"ext\";\n</code></pre>"},{"location":"schema/#rpc-interface-declarations","title":"RPC interface declarations","text":"<p>You can declare RPC calls in a schema, that define a set of functions that take a FlatBuffer as an argument (the request) and return a FlatBuffer as the response (both of which must be table types):</p> <pre><code>rpc_service MonsterStorage {\n    Store(Monster):StoreResponse;\n    Retrieve(MonsterId):Monster;\n}\n</code></pre> <p>What code this produces and how it is used depends on language and RPC system used, there is preliminary support for GRPC through the <code>--grpc</code> code generator, see <code>grpc/tests</code> for an example.</p>"},{"location":"schema/#comments-documentation","title":"Comments &amp; documentation","text":"<p>May be written as in most C-based languages. Additionally, a triple comment (<code>///</code>) on a line by itself signals that a comment is documentation for whatever is declared on the line after it (table/struct/field/enum/union/element), and the comment is output in the corresponding C++ code. Multiple such lines per item are allowed.</p>"},{"location":"schema/#attributes","title":"Attributes","text":"<p>Attributes may be attached to a declaration, behind a field/enum value, or after the name of a table/struct/enum/union. These may either have a value or not. Some attributes like <code>deprecated</code> are understood by the compiler; user defined ones need to be declared with the attribute declaration (like <code>priority</code> in the example above), and are available to query if you parse the schema at runtime. This is useful if you write your own code generators/editors etc., and you wish to add additional information specific to your tool (such as a help text).</p> <p>Current understood attributes:</p> <ul> <li><code>id: n</code> (on a table field): manually set the field identifier to <code>n</code>. If you   use this attribute, you must use it on ALL fields of this table, and the   numbers must be a contiguous range from 0 onwards. Additionally, since a union   type effectively adds two fields, its id must be that of the second field (the   first field is the type field and not explicitly declared in the schema). For   example, if the last field before the union field had id 6, the union field   should have id 8, and the unions type field will implicitly be 7. IDs allow   the fields to be placed in any order in the schema. When a new field is added   to the schema it must use the next available ID.</li> <li><code>deprecated</code> (on a field): do not generate accessors for this field anymore,   code should stop using this data. Old data may still contain this field, but   it won't be accessible anymore by newer code. Note that if you deprecate a   field that was previous required, old code may fail to validate new data (when   using the optional verifier).</li> </ul>"},{"location":"schema/#required","title":"<code>required</code>","text":"<ul> <li><code>required</code> (on a non-scalar table field): this field must always be set. By   default, fields do not need to be present in the binary. This is desirable, as   it helps with forwards/backwards compatibility, and flexibility of data   structures. By specifying this attribute, you make non- presence in an error   for both reader and writer. The reading code may access the field directly,   without checking for null. If the constructing code does not initialize this   field, they will get an assert, and also the verifier will fail on buffers   that have missing required fields. Both adding and removing this attribute may   be forwards/backwards incompatible as readers will be unable read old or new   data, respectively, unless the data happens to always have the field set.</li> <li><code>force_align: size</code> (on a struct): force the alignment of this struct to be   something higher than what it is naturally aligned to. Causes these structs to   be aligned to that amount inside a buffer, IF that buffer is allocated with   that alignment (which is not necessarily the case for buffers accessed   directly inside a <code>FlatBufferBuilder</code>). Note: currently not guaranteed to have   an effect when used with <code>--object-api</code>, since that may allocate objects at   alignments less than what you specify with <code>force_align</code>.</li> <li><code>force_align: size</code> (on a vector): force the alignment of this vector to be   something different than what the element size would normally dictate. Note:   Now only work for generated C++ code.</li> <li><code>bit_flags</code> (on an unsigned enum): the values of this field indicate bits,   meaning that any unsigned value N specified in the schema will end up   representing 1&lt;&lt;N, or if you don't specify values at all, you'll get the   sequence 1, 2, 4, 8, ...</li> <li><code>nested_flatbuffer: \"table_name\"</code> (on a field): this indicates that the field   (which must be a vector of ubyte) contains flatbuffer data, for which the root   type is given by <code>table_name</code>. The generated code will then produce a   convenient accessor for the nested FlatBuffer.</li> <li><code>flexbuffer</code> (on a field): this indicates that the field (which must be a   vector of ubyte) contains flexbuffer data. The generated code will then   produce a convenient accessor for the FlexBuffer root.</li> <li><code>key</code> (on a field): this field is meant to be used as a key when sorting a   vector of the type of table it sits in. Can be used for in-place binary   search.</li> <li><code>hash</code> (on a field). This is an (un)signed 32/64 bit integer field, whose   value during JSON parsing is allowed to be a string, which will then be stored   as its hash. The value of attribute is the hashing algorithm to use, one of   <code>fnv1_32</code> <code>fnv1_64</code> <code>fnv1a_32</code> <code>fnv1a_64</code>.</li> <li><code>original_order</code> (on a table): since elements in a table do not need to be   stored in any particular order, they are often optimized for space by sorting   them to size. This attribute stops that from happening. There should generally   not be any reason to use this flag.</li> <li>'native*'. Several attributes have been added to support the C++ object   Based API. All such attributes are prefixed with the term \"native\".</li> </ul>"},{"location":"schema/#json-parsing","title":"JSON Parsing","text":"<p>The same parser that parses the schema declarations above is also able to parse JSON objects that conform to this schema. So, unlike other JSON parsers, this parser is strongly typed, and parses directly into a FlatBuffer (see the compiler documentation on how to do this from the command line, or the C++ documentation on how to do this at runtime).</p> <p>Besides needing a schema, there are a few other changes to how it parses JSON:</p> <ul> <li>It accepts field names with and without quotes, like many JSON parsers already   do. It outputs them without quotes as well, though can be made to output them   using the <code>strict_json</code> flag.</li> <li>If a field has an enum type, the parser will recognize symbolic enum values   (with or without quotes) instead of numbers, e.g. <code>field: EnumVal</code>. If a field   is of integral type, you can still use symbolic names, but values need to be   prefixed with their type and need to be quoted, e.g. <code>field: \"Enum.EnumVal\"</code>.   For enums representing flags, you may place multiple inside a string separated   by spaces to OR them, e.g. <code>field: \"EnumVal1 EnumVal2\"</code> or   <code>field: \"Enum.EnumVal1 Enum.EnumVal2\"</code>.</li> <li>Similarly, for unions, these need to specified with two fields much like you   do when serializing from code. E.g. for a field <code>foo</code>, you must add a field   <code>foo_type: FooOne</code> right before the <code>foo</code> field, where <code>FooOne</code> would be the   table out of the union you want to use.</li> <li>A field that has the value <code>null</code> (e.g. <code>field: null</code>) is intended to have the   default value for that field (thus has the same effect as if that field wasn't   specified at all).</li> <li>It has some built in conversion functions, so you can write for example   <code>rad(180)</code> where ever you'd normally write <code>3.14159</code>. Currently supports the   following functions: <code>rad</code>, <code>deg</code>, <code>cos</code>, <code>sin</code>, <code>tan</code>, <code>acos</code>, <code>asin</code>,   <code>atan</code>.</li> </ul> <p>When parsing JSON, it recognizes the following escape codes in strings:</p> <ul> <li><code>\\n</code> - linefeed.</li> <li><code>\\t</code> - tab.</li> <li><code>\\r</code> - carriage return.</li> <li><code>\\b</code> - backspace.</li> <li><code>\\f</code> - form feed.</li> <li><code>\\\"</code> - double quote.</li> <li><code>\\\\</code> - backslash.</li> <li><code>\\/</code> - forward slash.</li> <li><code>\\uXXXX</code> - 16-bit unicode code point, converted to the equivalent UTF-8   representation.</li> <li><code>\\xXX</code> - 8-bit binary hexadecimal number XX. This is the only one that is not   in the JSON spec (see http://json.org/), but is needed to be able to encode   arbitrary binary in strings to text and back without losing information (e.g.   the byte 0xFF can't be represented in standard JSON).</li> </ul> <p>It also generates these escape codes back again when generating JSON from a binary representation.</p> <p>When parsing numbers, the parser is more flexible than JSON. A format of numeric literals is more close to the C/C++. According to the grammar, it accepts the following numerical literals:</p> <ul> <li>An integer literal can have any number of leading zero <code>0</code> digits. Unlike   C/C++, the parser ignores a leading zero, not interpreting it as the beginning   of the octal number. The numbers <code>[081, -00094]</code> are equal to <code>[81, -94]</code>   decimal integers.</li> <li>The parser accepts unsigned and signed hexadecimal integer numbers. For   example: <code>[0x123, +0x45, -0x67]</code> are equal to <code>[291, 69, -103]</code> decimals.</li> <li>The format of float-point numbers is fully compatible with C/C++ format. If a   modern C++ compiler is used the parser accepts hexadecimal and special   floating-point literals as well:   <code>[-1.0, 2., .3e0, 3.e4, 0x21.34p-5, -inf, nan]</code>.</li> </ul> <p>The following conventions for floating-point numbers are used:</p> <ul> <li>The exponent suffix of hexadecimal floating-point number is mandatory.</li> <li>Parsed <code>NaN</code> converted to unsigned IEEE-754 <code>quiet-NaN</code> value.</li> </ul> <p>Extended floating-point support was tested with:</p> <ul> <li>x64 Windows: <code>MSVC2015</code> and higher.</li> <li> <p>x64 Linux: <code>LLVM 6.0</code>, <code>GCC 4.9</code> and higher.</p> </li> <li> <p>For compatibility with a JSON lint tool all numeric literals of scalar fields   can be wrapped to quoted string:   <code>\"1\", \"2.0\", \"0x48A\", \"0x0C.0Ep-1\", \"-inf\", \"true\"</code>.</p> </li> </ul>"},{"location":"schema/#guidelines","title":"Guidelines","text":""},{"location":"schema/#efficiency","title":"Efficiency","text":"<p>FlatBuffers is all about efficiency, but to realize that efficiency you require an efficient schema. There are usually multiple choices on how to represent data that have vastly different size characteristics.</p> <p>It is very common nowadays to represent any kind of data as dictionaries (as in e.g. JSON), because of its flexibility and extensibility. While it is possible to emulate this in FlatBuffers (as a vector of tables with key and value(s)), this is a bad match for a strongly typed system like FlatBuffers, leading to relatively large binaries. FlatBuffer tables are more flexible than classes/structs in most systems, since having a large number of fields only few of which are actually used is still efficient. You should thus try to organize your data as much as possible such that you can use tables where you might be tempted to use a dictionary.</p> <p>Similarly, strings as values should only be used when they are truly open-ended. If you can, always use an enum instead.</p> <p>FlatBuffers doesn't have inheritance, so the way to represent a set of related data structures is a union. Unions do have a cost however, so an alternative to a union is to have a single table that has all the fields of all the data structures you are trying to represent, if they are relatively similar / share many fields. Again, this is efficient because non-present fields are cheap.</p> <p>FlatBuffers supports the full range of integer sizes, so try to pick the smallest size needed, rather than defaulting to int/long.</p> <p>Remember that you can share data (refer to the same string/table within a buffer), so factoring out repeating data into its own data structure may be worth it.</p>"},{"location":"schema/#style-guide","title":"Style guide","text":"<p>Identifiers in a schema are meant to translate to many different programming languages, so using the style of your \"main\" language is generally a bad idea.</p> <p>For this reason, below is a suggested style guide to adhere to, to keep schemas consistent for interoperation regardless of the target language.</p> <p>Where possible, the code generators for specific languages will generate identifiers that adhere to the language style, based on the schema identifiers.</p> <ul> <li>Table, struct, enum and rpc names (types): UpperCamelCase.</li> <li>Table and struct field names: snake_case. This is translated to lowerCamelCase   automatically for some languages, e.g. Java.</li> <li>Enum values: UpperCamelCase.</li> <li>namespaces: UpperCamelCase.</li> </ul> <p>Formatting (this is less important, but still worth adhering to):</p> <ul> <li>Opening brace: on the same line as the start of the declaration.</li> <li>Spacing: Indent by 2 spaces. None around <code>:</code> for types, on both sides for <code>=</code>.</li> </ul> <p>For an example, see the schema at the top of this file.</p>"},{"location":"schema/#gotchas","title":"Gotchas","text":""},{"location":"schema/#testing-whether-a-field-is-present-in-a-table","title":"Testing whether a field is present in a table","text":"<p>Most serialization formats (e.g. JSON or Protocol Buffers) make it very explicit in the format whether a field is present in an object or not, allowing you to use this as \"extra\" information.</p> <p>FlatBuffers will not write fields that are equal to their default value, sometimes resulting in significant space savings. However, this also means we cannot disambiguate the meaning of non-presence as \"written default value\" or \"not written at all\". This only applies to scalar fields since only they support default values. Unless otherwise specified, their default is 0.</p> <p>If you care about the presence of scalars, most languages support \"optional scalars.\" You can set <code>null</code> as the default value in the schema. <code>null</code> is a value that's outside of all types, so we will always write if <code>add_field</code> is called. The generated field accessor should use the local language's canonical optional type.</p> <p>Some <code>FlatBufferBuilder</code> implementations have an option called <code>force_defaults</code> that circumvents this \"not writing defaults\" behavior you can then use <code>IsFieldPresent</code> to query presence. / Another option that works in all languages is to wrap a scalar field in a struct. This way it will return null if it is not present. This will be slightly less ergonomic but structs don't take up any more space than the scalar they represent.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial provides an example of how to work with FlatBuffers in a variety of languages. The following topics will cover all the steps of using FlatBuffers in your application.</p> <ol> <li>Writing a FlatBuffers schema file (<code>.fbs</code>).</li> <li>Using the <code>flatc</code> compiler to transform the schema into language-specific    code.</li> <li>Importing the generated code and libraries into your application.</li> <li>Serializing data into a flatbuffer.</li> <li>Deserializing a flatbuffer.</li> </ol> <p>Note</p> <p>The tutorial is structured to be language agnostic, with language specifics in code blocks providing more context. Additionally, this tries to cover the major parts and type system of flatbuffers to give a general overview. It's not expected to be an exhaustive list of all features, or provide the best way to do things.</p>"},{"location":"tutorial/#flatbuffers-schema-fbs","title":"FlatBuffers Schema (<code>.fbs</code>)","text":"<p>To start working with FlatBuffers, you first need to create a schema file which defines the format of the data structures you wish to serialize. The schema is processed by the <code>flatc</code> compiler to generate language-specific code that you use in your projects.</p> <p>The following <code>monster.fbs</code> schema will be used for this tutorial. This is part of the FlatBuffers sample code to give complete sample binaries demonstrations.</p> <p>FlatBuffers schema is a Interface Definition Language (IDL) that has a couple data structures, see the schema documentation for a detail description. Use the inline code annotations to get a brief synopsis of each part of the schema.</p> monster.fbs<pre><code>// Example IDL file for our monster's schema.\n\nnamespace MyGame.Sample; //(1)!\n\nenum Color:byte { Red = 0, Green, Blue = 2 } //(2)!\n\n// Optionally add more tables.\nunion Equipment { Weapon } //(3)!\n\nstruct Vec3 { //(4)!\n  x:float; //(5)!\n  y:float;\n  z:float;\n}\n\ntable Monster { //(6)!\n  pos:Vec3; //(7)!\n  mana:short = 150; //(8)!\n  hp:short = 100;\n  name:string; //(9)!\n  friendly:bool = false (deprecated); //(10)!\n  inventory:[ubyte]; //(11)!\n  color:Color = Blue;\n  weapons:[Weapon]; //(12)!\n  equipped:Equipment; //(13)!\n  path:[Vec3];\n}\n\ntable Weapon {\n  name:string;\n  damage:short;\n}\n\nroot_type Monster; //(14)!\n</code></pre> <ol> <li> <p>FlatBuffers has support for namespaces to place the generated code into.    There is mixed level of support for namespaces (some languages don't have    namespaces), but for the C family of languages, it is fully supported.</p> </li> <li> <p>Enums definitions can be defined with the backing numerical type. Implicit    numbering is supported, so that <code>Green</code> would have a value of 1.</p> </li> <li> <p>A union represents a single value from a set of possible values. Its    effectively an enum (to represent the type actually store) and a value,    combined into one. In this example, the union is not very useful, since it    only has a single type.</p> </li> <li> <p>A struct is a collection of scalar fields with names. It is itself a scalar    type, which uses less memory and has faster lookup. However, once a struct is    defined, it cannot be changed. Use tables for data structures that can evolve    over time.</p> </li> <li> <p>FlatBuffers has the standard set of scalar numerical types (<code>int8</code>, <code>int16</code>,    <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>float</code>, <code>double</code>),    as well as <code>bool</code>. Note, scalars are fixed width, <code>varints</code> are not    supported.</p> </li> <li> <p>Tables are the main data structure for grouping data together. It can evolve    by adding and deprecating fields over time, while preserving forward and    backwards compatibility.</p> </li> <li> <p>A field that happens to be a <code>struct</code>. This means the data of the <code>Vec3</code>    struct will be serialized inline in the table without any need for offset.</p> </li> <li> <p>Fields can be provided a default value. Default values can be configured to    not be serialized at all while still providing the default value while    deserializing. However, once set, a default value cannot be changed.</p> </li> <li> <p>A <code>string</code> field which points to a serialized string external to the table.</p> </li> <li> <p>A deprecated field that is no longer being used. This is used instead of     removing the field outright.</p> </li> <li> <p>A <code>vector</code> field that points to a vector of bytes. Like <code>strings</code>, the     vector data is serialized elsewhere and this field just stores an offset to     the vector.</p> </li> <li> <p>Vector of <code>tables</code> and <code>structs</code> are also possible.</p> </li> <li> <p>A field to a <code>union</code> type.</p> </li> <li> <p>The root of the flatbuffer is always a <code>table</code>. This indicates the type of     <code>table</code> the \"entry\" point of the flatbuffer will point to.</p> </li> </ol> <p>Get FlatBuffers schema syntax highlighting</p>"},{"location":"tutorial/#compiling-schema-to-code-flatc","title":"Compiling Schema to Code (<code>flatc</code>)","text":"<p>After a schema file is written, you compile it to code in the languages you wish to work with. This compilation is done by the FlatBuffers Compiler (<code>flatc</code>) which is one of the binaries built in the repo.</p>"},{"location":"tutorial/#building-flatc","title":"Building <code>flatc</code>","text":"<p>FlatBuffers uses <code>cmake</code> to build projects files for your environment.</p> UnixWindows <pre><code>cmake -G \"Unix Makefiles\"\nmake flatc\n</code></pre> <pre><code>cmake -G \"Visual Studio 17 2022\"\nmsbuild.exe FlatBuffers.sln\n</code></pre> <p>See the documentation on building for more details and other environments. Some languages also include a prebuilt <code>flatc</code> via their package manager.</p>"},{"location":"tutorial/#compiling-schema","title":"Compiling Schema","text":"<p>To compile the schema, invoke <code>flatc</code> with the schema file and the language flags you wish to generate code for. This compilation will generate files that you include in your application code. These files provide convenient APIs for serializing and deserializing the flatbuffer binary data.</p> C++C# <pre><code>flatc --cpp monster.fbs\n</code></pre> <pre><code>flatc --csharp monster.fbs\n</code></pre> <p>Tip</p> <p>You can deserialize flatbuffers in languages that differ from the language that serialized it. For purpose of this tutorial, we assume one language is used for both serializing and deserializing.</p>"},{"location":"tutorial/#application-integration","title":"Application Integration","text":"<p>The generated files are then included in your project to be built into your application. This is heavily dependent on your build system and language, but generally involves two things:</p> <ol> <li>Importing the generated code.</li> <li>Importing the \"runtime\" libraries.</li> </ol> C++C# <pre><code>#include \"monster_generated.h\" // This was generated by `flatc`\n#include \"flatbuffers.h\" // The runtime library for C++\n\n// Simplifies naming in the following examples.\nusing namespace MyGame::Sample; // Specified in the schema.\n</code></pre> <pre><code>using Google.FlatBuffers; // The runtime library for C#\nusing MyGame.Sample; // The generated files from `flatc`\n</code></pre> <p>For some languages the runtime libraries are just code files you compile into your application. While other languages provide packaged libraries via their package managers.</p> <p>Note</p> <p>The generated files include APIs for both serializing and deserializing flatbuffers. So these steps are identical for both the consumer and producer.</p>"},{"location":"tutorial/#serialization","title":"Serialization","text":"<p>Once all the files are included into your application, it's time to start serializing some data!</p> <p>With FlatBuffers, serialization can be a bit verbose, since each piece of data must be serialized separately and in a particular order (depth-first, pre-order traversal). The verbosity allows efficient serialization without heap allocations, at the cost of more complex serialization APIs.</p> <p>For example, any reference type (e.g. <code>table</code>, <code>vector</code>, <code>string</code>) must be serialized before it can be referred to by other structures. So its typical to serialize the data from leaf to root node, as will be shown below.</p>"},{"location":"tutorial/#flatbufferbuilder","title":"FlatBufferBuilder","text":"<p>Most languages use a Builder object for managing the binary array that the data is serialized into. It provides an API for serializing data, as well as keeps track of some internal state. The generated code wraps methods on the Builder object to provide an API tailored to the schema.</p> <p>First instantiate a Builder (or reuse an existing one) and specify some memory for it. The builder will automatically resize the backing buffer when necessary.</p> C++C# <pre><code>// Construct a Builder with 1024 byte backing array.\nflatbuffers::FlatBufferBuidler builder(1024);\n</code></pre> <pre><code>// Construct a Builder with 1024 byte backing array.\nFlatBufferBuilder builder = new FlatBufferBuilder(1024);\n</code></pre> <p>Once a Builder is available, data can be serialized to it via the Builder APIs and the generated code.</p>"},{"location":"tutorial/#serializing-data","title":"Serializing Data","text":"<p>In this tutorial, we are building <code>Monsters</code> and <code>Weapons</code> for a computer game. A <code>Weapon</code> is represented by a flatbuffer <code>table</code> with some fields. One field is the <code>name</code> field, which is type <code>string</code>.</p> monster.fbs<pre><code>table Weapon {\n  name:string;\n  damage:short;\n}\n</code></pre>"},{"location":"tutorial/#strings","title":"Strings","text":"<p>Since <code>string</code> is a reference type, we first need to serialize it before assigning it to the <code>name</code> field of the <code>Weapon</code> table. This is done through the Builder <code>CreateString</code> method:</p> C++C# <pre><code>flatbuffers::Offset&lt;String&gt; weapon_one_name = builder.CreateString(\"Sword\");\nflatbuffers::Offset&lt;String&gt; weapon_two_name = builder.CreateString(\"Axe\");\n</code></pre> <pre><code>Offset&lt;String&gt; weaponOneName = builder.CreateString(\"Sword\");\nOffset&lt;String&gt; weaponTwoName = builder.CreateString(\"Axe\");\n</code></pre> <p>This performs the actual serialization (the string data is copied into the backing array) and returns an offset. Think of the offset as a handle to that reference. It's just a \"typed\" numerical offset to where that data resides in the buffer.</p>"},{"location":"tutorial/#tables","title":"Tables","text":"<p>Now that we have some names serialized, we can serialize <code>Weapons</code>. Here we will use one of the generated helper functions that was emitted by <code>flatc</code>. The <code>CreateWeapon</code> function takes in the Builder object, as well as the offset to the weapon's name and a numerical value for the damage field.</p> C++C# <pre><code>short weapon_one_damage = 3;\nshort weapon_two_damage = 5;\n\n// Use the `CreateWeapon()` shortcut to create Weapons with all the fields set.\nflatbuffers::Offset&lt;Weapon&gt; sword =\n    CreateWeapon(builder, weapon_one_name, weapon_one_damage);\nflatbuffers::Offset&lt;Weapon&gt; axe =\n    CreateWeapon(builder, weapon_two_name, weapon_two_damage);\n</code></pre> <pre><code>short weaponOneDamage = 3;\nshort weaponTwoDamage = 5;\n\n// Use the `CreateWeapon()` helper function to create the weapons, since we set every field.\nOffset&lt;Weapon&gt; sword =\n    Weapon.CreateWeapon(builder, weaponOneName, weaponOneDamage);\nOffset&lt;Weapon&gt; axe =\n    Weapon.CreateWeapon(builder, weaponTwoName, weaponTwoDamage);\n</code></pre> <p>Tip</p> <p>The generated functions from <code>flatc</code>, like <code>CreateWeapon</code>, are just composed of various Builder API methods. So its not required to use the generated code, but it does make things much simpler and compact.</p> <p>Just like the <code>CreateString</code> methods, the table serialization functions return an offset to the location of the serialized <code>Weapon</code> table.</p> <p>Now that we have some <code>Weapons</code> serialized, we can serialize a <code>Monster</code>. Looking at the schema again, this table has a lot more fields of various types. Some of these need to be serialized beforehand, for the same reason we serialized the name string before the weapon table.</p> <p>Note</p> <p>There is no prescribed ordering of which table fields must be serialized first, you could serialize in any order you want. You can also not serialize a field to provide a <code>null</code> value, this is done by using an 0 offset value.</p> monster.fbs<pre><code>table Monster {\n  pos:Vec3;\n  mana:short = 150;\n  hp:short = 100;\n  name:string;\n  friendly:bool = false (deprecated);\n  inventory:[ubyte];\n  color:Color = Blue;\n  weapons:[Weapon];\n  equipped:Equipment;\n  path:[Vec3];\n}\n</code></pre>"},{"location":"tutorial/#vectors","title":"Vectors","text":"<p>The <code>weapons</code> field is a <code>vector</code> of <code>Weapon</code> tables. We already have two <code>Weapons</code> serialized, so we just need to serialize a <code>vector</code> of those offsets. The Builder provides multiple ways to create <code>vectors</code>.</p> C++C# <pre><code>// Create a std::vector of the offsets we had previous made.\nstd::vector&lt;flatbuffers::Offset&lt;Weapon&gt;&gt; weapons_vector;\nweapons_vector.push_back(sword);\nweapons_vector.push_back(axe);\n\n// Then serialize that std::vector into the buffer and again get an Offset\n// to that vector. Use `auto` here since the full type is long, and it just\n// a \"typed\" number.\nauto weapons = builder.CreateVector(weapons_vector);\n</code></pre> <pre><code>// Create an array of the two weapon offsets.\nvar weaps = new Offset&lt;Weapon&gt;[2];\nweaps[0] = sword;\nweaps[1] = axe;\n\n// Pass the `weaps` array into the `CreateWeaponsVector()` method to create\n// a FlatBuffer vector.\nvar weapons = Monster.CreateWeaponsVector(builder, weaps);\n</code></pre> <p>While we are at it, let us serialize the other two vector fields: the <code>inventory</code> field is just a vector of scalars, and the <code>path</code> field is a vector of structs (which are scalar data as well). So these vectors can be serialized a bit more directly.</p> C++C# <pre><code>// Construct an array of two `Vec3` structs.\nVec3 points[] = { Vec3(1.0f, 2.0f, 3.0f), Vec3(4.0f, 5.0f, 6.0f) };\n\n// Serialize it as a vector of structs.\nflatbuffers::Offset&lt;flatbuffers::Vector&lt;Vec3&gt;&gt; path =\n    builder.CreateVectorOfStructs(points, 2);\n\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\nunsigned char treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nflatbuffers::Offset&lt;flatbuffers::Vector&lt;unsigned char&gt;&gt; inventory =\n    builder.CreateVector(treasure, 10);\n</code></pre> <pre><code>// Start building a path vector of length 2.\nMonster.StartPathVector(fbb, 2);\n\n// Serialize the individual Vec3 structs\nVec3.CreateVec3(builder, 1.0f, 2.0f, 3.0f);\nVec3.CreateVec3(builder, 4.0f, 5.0f, 6.0f);\n\n// End the vector to get the offset\nOffset&lt;Vector&lt;Vec3&gt;&gt; path = fbb.EndVector();\n\n// Create a `vector` representing the inventory of the Orc. Each number\n// could correspond to an item that can be claimed after he is slain.\n// Note: Since we prepend the bytes, this loop iterates in reverse order.\nMonster.StartInventoryVector(builder, 10);\nfor (int i = 9; i &gt;= 0; i--)\n{\n    builder.AddByte((byte)i);\n}\nOffset&lt;Vector&lt;byte&gt;&gt; inventory = builder.EndVector();\n</code></pre>"},{"location":"tutorial/#unions","title":"Unions","text":"<p>The last non-scalar data for the <code>Monster</code> table is the <code>equipped</code> <code>union</code> field. For this case, we will reuse an already serialized <code>Weapon</code> (the only type in the union), without needing to reserialize it. Union fields implicitly add a hidden <code>_type</code> field that stores the type of value stored in the union. When serializing a union, you must explicitly set this type field, along with providing the union value.</p> <p>We will also serialize the other scalar data at the same time, since we have all the necessary values and Offsets to make a <code>Monster</code>.</p> C++C# <pre><code>// Create the remaining data needed for the Monster.\nauto name = builder.CreateString(\"Orc\");\n\n// Create the position struct\nauto position = Vec3(1.0f, 2.0f, 3.0f);\n\n// Set his hit points to 300 and his mana to 150.\nint hp = 300;\nint mana = 150;\n\n// Finally, create the monster using the `CreateMonster` helper function\n// to set all fields.\n//\n// Here we set the union field by using the `.Union()` method of the\n// `Offset&lt;Weapon&gt;` axe we already serialized above. We just have to specify\n// which type of object we put in the union, and do that with the\n// auto-generated `Equipment_Weapon` enum.\nflatbuffers::Offset&lt;Monster&gt; orc =\n    CreateMonster(builder, &amp;position, mana, hp, name, inventory,\n                  Color_Red, weapons, Equipment_Weapon, axe.Union(),\n                  path);\n</code></pre> <pre><code>// Create the remaining data needed for the Monster.\nvar name = builder.CreateString(\"Orc\");\n\n// Create our monster using `StartMonster()` and `EndMonster()`.\nMonster.StartMonster(builder);\nMonster.AddPos(builder, Vec3.CreateVec3(builder, 1.0f, 2.0f, 3.0f));\nMonster.AddHp(builder, (short)300);\nMonster.AddName(builder, name);\nMonster.AddInventory(builder, inv);\nMonster.AddColor(builder, Color.Red);\nMonster.AddWeapons(builder, weapons);\n// For union fields, we explicitly add the auto-generated enum for the type\n// of value stored in the union.\nMonster.AddEquippedType(builder, Equipment.Weapon);\n// And we just use the `.Value` property of the already serialized axe.\nMonster.AddEquipped(builder, axe.Value); // Axe\nMonster.AddPath(builder, path);\nOffset&lt;Monster&gt; orc = Monster.EndMonster(builder);\n</code></pre> <p>Warning</p> <p>When serializing tables, you must fully serialize it before attempting to serialize another reference type. If you try to serialize in a nested manner, you will get an assert/exception/panic depending on your language.</p>"},{"location":"tutorial/#finishing","title":"Finishing","text":"<p>At this point, we have serialized a <code>Monster</code> we've named \"orc\" to the flatbuffer and have its offset. The <code>root_type</code> of the schema is also a <code>Monster</code>, so we have everything we need to finish the serialization step.</p> <p>This is done by calling the appropriate <code>finish</code> method on the Builder, passing in the orc offset to indicate this <code>table</code> is the \"entry\" point when deserializing the buffer later.</p> C++C# <pre><code>// Call `Finish()` to instruct the builder that this monster is complete.\n// You could also call `FinishMonsterBuffer(builder, orc);`\nbuilder.Finish(orc);\n</code></pre> <pre><code>// Call `Finish()` to instruct the builder that this monster is complete.\n// You could also call `Monster.FinishMonsterBuffer(builder, orc);`\nbuilder.Finish(orc.Value);\n</code></pre> <p>Once you finish a Builder, you can no longer serialize more data to it.</p>"},{"location":"tutorial/#buffer-access","title":"Buffer Access","text":"<p>The flatbuffer is now ready to be stored somewhere, sent over the network, compressed, or whatever you would like to do with it. You access the raw buffer like so:</p> C++C# <pre><code>// This must be called after `Finish()`.\nuint8_t *buf = builder.GetBufferPointer();\n\n// Returns the size of the buffer that `GetBufferPointer()` points to.\nint size = builder.GetSize();\n</code></pre> <pre><code>// This must be called after `Finish()`.\n//\n// The data in this ByteBuffer does NOT start at 0, but at buf.Position.\n// The end of the data is marked by buf.Length, so the size is\n// buf.Length - buf.Position.\nFlatBuffers.ByteBuffer dataBuffer = builder.DataBuffer;\n\n// Alternatively this copies the above data out of the ByteBuffer for you:\nbyte[] buf = builder.SizedByteArray();\n</code></pre> <p>Now you can write the bytes to a file or send them over the network. The buffer stays valid until the Builder is cleared or destroyed.</p> <p>BINARY Mode</p> <p>Make sure your file mode (or transfer protocol) is set to BINARY, and not TEXT. If you try to transfer a flatbuffer in TEXT mode, the buffer will be corrupted and be hard to diagnose.</p>"},{"location":"tutorial/#deserialization","title":"Deserialization","text":"<p>Misnomer</p> <p>Deserialization is a bit of a misnomer, since FlatBuffers doesn't deserialize the whole buffer when accessed. It just \"decodes\" the data that is requested, leaving all the other data untouched. It is up to the application to decide if the data is copied out or even read in the first place. However, we continue to use the word <code>deserialize</code> to mean accessing data from a binary flatbuffer.</p> <p>Now that we have successfully create an orc FlatBuffer, the data can be saved, sent over a network, etc. At some point, the buffer will be accessed to obtain the underlying data.</p> <p>The same application setup used for serialization is needed for deserialization (see application integration).</p>"},{"location":"tutorial/#root-access","title":"Root Access","text":"<p>All access to the data in the flatbuffer must first go through the root object. There is only one root object per flatbuffer. The generated code provides functions to get the root object given the buffer.</p> C++C# <pre><code>uint8_t *buffer_pointer = /* the data you just read */;\n\n// Get an view to the root object inside the buffer.\nMonster monster = GetMonster(buffer_pointer);\n</code></pre> <pre><code>byte[] bytes = /* the data you just read */\n\n// Get an view to the root object inside the buffer.\nMonster monster = Monster.GetRootAsMonster(new ByteBuffer(bytes));\n</code></pre> <p>BINARY mode</p> <p>Again, make sure you read the bytes in BINARY mode, otherwise the buffer may be corrupted.</p> <p>In most languages, the returned object is just a \"view\" of the data with helpful accessors. Data is typically not copied out of the backing buffer. This also means the backing buffer must remain alive for the duration of the views.</p>"},{"location":"tutorial/#table-access","title":"Table Access","text":"<p>If you look in the generated files emitted by <code>flatc</code>, you will see it generated , for each <code>table</code>, accessors of all its non-<code>deprecated</code> fields. For example, some of the accessors of the <code>Monster</code> root table would look like:</p> C++C# <pre><code>auto hp = monster-&gt;hp();\nauto mana = monster-&gt;mana();\nauto name = monster-&gt;name()-&gt;c_str();\n</code></pre> <pre><code>// For C#, unlike most other languages support by FlatBuffers, most values\n// (except for vectors and unions) are available as properties instead of\n// accessor methods.\nvar hp = monster.Hp;\nvar mana = monster.Mana;\nvar name = monster.Name;\n</code></pre> <p>These accessors should hold the values <code>300</code>, <code>150</code>, and <code>\"Orc\"</code> respectively.</p> <p>Default Values</p> <p>The default value of <code>150</code> wasn't stored in the <code>mana</code> field, but we are still able to retrieve it. That is because the generated accessors return a hard-coded default value when it doesn't find the value in the buffer.</p>"},{"location":"tutorial/#nested-object-access","title":"Nested Object Access","text":"<p>Accessing nested objects is very similar, with the nested field pointing to another object type. Be careful, the field could be <code>null</code> if not present.</p> <p>For example, accessing the <code>pos</code> <code>struct</code>, which is type <code>Vec3</code> you would do:</p> C++C# <pre><code>auto pos = monster-&gt;pos();\nauto x = pos-&gt;x();\nauto y = pos-&gt;y();\nauto z = pos-&gt;z();\n</code></pre> <pre><code>var pos = monster.Pos.Value;\nvar x = pos.X;\nvar y = pos.Y;\nvar z = pos.Z;\n</code></pre> <p>Where <code>x</code>, <code>y</code>, and <code>z</code> will contain <code>1.0</code>, <code>2.0</code>, and <code>3.0</code> respectively.</p>"},{"location":"tutorial/#vector-access","title":"Vector Access","text":"<p>Similarly, we can access elements of the <code>inventory</code> <code>vector</code> by indexing it. You can also iterate over the length of the vector.</p> C++C# <pre><code>flatbuffers::Vector&lt;unsigned char&gt; inv = monster-&gt;inventory();\nauto inv_len = inv-&gt;size();\nauto third_item = inv-&gt;Get(2);\n</code></pre> <pre><code>int invLength = monster.InventoryLength;\nvar thirdItem = monster.Inventory(2);\n</code></pre> <p>For vectors of tables, you can access the elements like any other vector, except you need to handle the result as a FlatBuffer table. Here we iterate over the <code>weapons</code> vector that is houses <code>Weapon</code> <code>tables</code>.</p> C++C# <pre><code>flatbuffers::Vector&lt;Weapon&gt; weapons = monster-&gt;weapons();\nauto weapon_len = weapons-&gt;size();\nauto second_weapon_name = weapons-&gt;Get(1)-&gt;name()-&gt;str();\nauto second_weapon_damage = weapons-&gt;Get(1)-&gt;damage()\n</code></pre> <pre><code>int weaponsLength = monster.WeaponsLength;\nvar secondWeaponName = monster.Weapons(1).Name;\nvar secondWeaponDamage = monster.Weapons(1).Damage;\n</code></pre>"},{"location":"tutorial/#union-access","title":"Union Access","text":"<p>Lastly , we can access our <code>equipped</code> <code>union</code> field. Just like when we created the union, we need to get both parts of the union: the type and the data.</p> <p>We can access the type to dynamically cast the data as needed (since the union only stores a FlatBuffer <code>table</code>).</p> C++C# <pre><code>auto union_type = monster.equipped_type();\n\nif (union_type == Equipment_Weapon) {\n     // Requires `static_cast` to type `const Weapon*`.\n    auto weapon = static_cast&lt;const Weapon*&gt;(monster-&gt;equipped());\n\n    auto weapon_name = weapon-&gt;name()-&gt;str(); // \"Axe\"\n    auto weapon_damage = weapon-&gt;damage();    // 5\n}\n</code></pre> <pre><code>var unionType = monster.EquippedType;\n\nif (unionType == Equipment.Weapon) {\n    var weapon = monster.Equipped&lt;Weapon&gt;().Value;\n\n    var weaponName = weapon.Name;     // \"Axe\"\n    var weaponDamage = weapon.Damage; // 5\n}\n</code></pre>"}]}